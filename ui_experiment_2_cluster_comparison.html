<!DOCTYPE html>
<html>
<head>
    <title>UI Experiment 2: Multi-Cluster Performance Comparison</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f8f9fa; }
        .container { max-width: 1600px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .controls { background: #f1f3f4; padding: 15px; border-radius: 6px; margin-bottom: 20px; display: flex; flex-wrap: wrap; gap: 15px; }
        .filter-group { display: flex; flex-direction: column; }
        .filter-group label { font-weight: bold; margin-bottom: 5px; }
        .filter-group select, .filter-group input { padding: 5px; border: 1px solid #ccc; border-radius: 4px; }
        .chart-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
        .chart-container { height: 450px; border: 1px solid #ddd; border-radius: 6px; padding: 10px; margin-bottom: 20px; }
        .comparison-table { margin-top: 40px; }
        .comparison-table table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .comparison-table th, .comparison-table td { padding: 6px 8px; border: 1px solid #ddd; text-align: center; }
        .comparison-table th { background-color: #e9ecef; font-weight: bold; }
        .comparison-table tr:nth-child(even) { background-color: #f8f9fa; }
        .comparison-table tr:nth-child(odd) { background-color: #ffffff; }
        .winner { background-color: #d4edda !important; font-weight: bold; }
        .winner td { background-color: #d4edda !important; }
        .second { background-color: #d1ecf1 !important; }
        .second td { background-color: #d1ecf1 !important; }
        .third { background-color: #fff3cd !important; }
        .third td { background-color: #fff3cd !important; }
        .stats-summary { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; }
        .stat-card { background: #f8f9fa; padding: 15px; border-radius: 6px; text-align: center; border-left: 4px solid #007bff; }
        .stat-value { font-size: 24px; font-weight: bold; color: #007bff; }
        .stat-label { font-size: 14px; color: #6c757d; margin-top: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Multi-Cluster Performance Comparison for nyc_taxis, 60c</h1>
        <p><strong>Purpose:</strong> Compare performance characteristics across different cluster configurations to identify the best performing setup for specific workload requirements.</p>
        
        <div class="controls">
            <div class="filter-group">
                <label>Metric Focus:</label>
                <select id="metricFocus">
                    <option value="throughput">Max Throughput</option>
                    <option value="latency">Min Latency</option>
                    <option value="efficiency">Best Efficiency</option>
                    <option value="consistency">Most Consistent</option>
                </select>
            </div>
            <div class="filter-group">
                <label>Latency Percentile:</label>
                <select id="latencyPercentile">
                    <option value="99">P99</option>
                    <option value="90">P90</option>
                    <option value="50">P50</option>
                </select>
            </div>
            <div class="filter-group">
                <label>Client Load:</label>
                <select id="clientLoad">
                    <option value="all">All Loads</option>
                    <option value="60">60 Clients</option>
                    <option value="80">80 Clients</option>
                    <option value="100">100 Clients</option>
                </select>
            </div>
            <div class="filter-group">
                <label>Configuration:</label>
                <select id="configFilter">
                    <option value="all">All Configs</option>
                    <option value="16-16">16 nodes, 16 shards</option>
                    <option value="20-20">20 nodes, 20 shards</option>
                    <option value="32-32">32 nodes, 32 shards</option>
                </select>
            </div>
            <div class="filter-group">
                <label>Show Outliers:</label>
                <input type="checkbox" id="showOutliers" checked>
            </div>
        </div>

        <div class="stats-summary">
            <div class="stat-card">
                <div class="stat-value" id="bestThroughput">-</div>
                <div class="stat-label">Best Throughput<br><span id="bestThroughputCluster">-</span></div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="bestLatency">-</div>
                <div class="stat-label">Best P99 Latency<br><span id="bestLatencyCluster">-</span></div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="bestEfficiency">-</div>
                <div class="stat-label">Best Efficiency<br><span id="bestEfficiencyCluster">-</span></div>
            </div>
        </div>

        <div class="chart-grid">
            <div class="chart-container">
                <div id="throughputComparison"></div>
            </div>
            <div class="chart-container">
                <div id="latencyComparison"></div>
            </div>
            <div class="chart-container">
                <div id="variabilityComparison"></div>
            </div>
            <div class="chart-container">
                <div id="efficiencyComparison"></div>
            </div>
        </div>
        
        <div class="comparison-table">
            <h3>Detailed Performance Comparison by Configuration</h3>
            <table id="comparisonTable">
                <thead>
                    <tr>
                        <th rowspan="3">Cluster</th>
                        <th rowspan="3">Config</th>
                        <th rowspan="3">Clients</th>
                        <th colspan="4">Throughput (docs/s)</th>
                        <th colspan="12">Latency (ms)</th>
                        <th rowspan="3">Efficiency</th>
                        <th rowspan="3">CV %</th>
                        <th rowspan="3">Rank</th>
                    </tr>
                    <tr>
                        <th colspan="4">Repetitions</th>
                        <th colspan="4">P99</th>
                        <th colspan="4">P90</th>
                        <th colspan="4">P50</th>
                    </tr>
                    <tr>
                        <th>Rep1</th>
                        <th>Rep2</th>
                        <th>Rep3</th>
                        <th>Rep4</th>
                        <th>Rep1</th>
                        <th>Rep2</th>
                        <th>Rep3</th>
                        <th>Rep4</th>
                        <th>Rep1</th>
                        <th>Rep2</th>
                        <th>Rep3</th>
                        <th>Rep4</th>
                        <th>Rep1</th>
                        <th>Rep2</th>
                        <th>Rep3</th>
                        <th>Rep4</th>
                    </tr>
                </thead>
                <tbody id="comparisonTableBody">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Extended sample data with more configurations
        const performanceData = [
            {
                        "cluster": "c4a-72 64k",
                        "config": "60_16-16",
                        "clients": 60,
                        "nodes": 16,
                        "shards": 16,
                        "throughput": [
                                    627175,
                                    624806,
                                    632199,
                                    590024
                        ],
                        "latency": [
                                    1771,
                                    1890,
                                    1851,
                                    2080
                        ],
                        "latency_p90": [
                                    1353,
                                    1393,
                                    1375,
                                    1424
                        ],
                        "latency_p50": [
                                    850,
                                    903,
                                    773,
                                    907
                        ]
            }
];

        function calculateStats(data) {
            const validData = data.filter(x => x > 0);
            if (validData.length === 0) return {mean: 0, std: 0, cv: 0};
            
            const mean = validData.reduce((a, b) => a + b, 0) / validData.length;
            const variance = validData.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / validData.length;
            const std = Math.sqrt(variance);
            const cv = (std / mean) * 100;
            
            return {mean, std, cv};
        }

        function calculateEfficiency(throughput, latency) {
            return Math.round(throughput / (latency / 1000));
        }

        function updateCharts() {
            const metricFocus = document.getElementById('metricFocus').value;
            const clientLoad = document.getElementById('clientLoad').value;
            const configFilter = document.getElementById('configFilter').value;
            const showOutliers = document.getElementById('showOutliers').checked;

            let filteredData = performanceData;

            // Apply filters
            if (clientLoad !== 'all') {
                filteredData = filteredData.filter(d => d.clients === parseInt(clientLoad));
            }

            if (configFilter !== 'all') {
                const [nodes, shards] = configFilter.split('-');
                filteredData = filteredData.filter(d => d.nodes === parseInt(nodes) && d.shards === parseInt(shards));
            }

            // Update throughput comparison
            updateThroughputChart(filteredData, showOutliers);
            updateLatencyChart(filteredData, showOutliers);
            updateVariabilityChart(filteredData);
            updateEfficiencyChart(filteredData);
            updateComparisonTable(filteredData);
            updateStatsSummary(filteredData);
        }

        function updateThroughputChart(data, showOutliers) {
            const traces = data.map(d => {
                const stats = calculateStats(d.throughput);
                return {
                    y: d.throughput.filter(x => x > 0),
                    type: 'box',
                    name: d.cluster,
                    boxpoints: showOutliers ? 'outliers' : false,
                    marker: {color: getClusterColor(d.cluster)}
                };
            });

            const layout = {
                title: 'Throughput Distribution by Cluster<br><sub>Mean throughput across repetitions</sub>',
                yaxis: {title: 'Throughput (docs/s)'},
                margin: {b: 120},
                showlegend: false
            };

            Plotly.newPlot('throughputComparison', traces, layout);
        }

        function updateLatencyChart(data, showOutliers) {
            const percentile = document.getElementById('latencyPercentile').value;
            const latencyField = percentile === '99' ? 'latency' : 
                                percentile === '90' ? 'latency_p90' : 'latency_p50';
            
            const traces = data.map(d => {
                const latencyData = d[latencyField] || d.latency;
                return {
                    y: Array.isArray(latencyData) ? latencyData.filter(x => x > 0) : [latencyData],
                    type: 'box',
                    name: d.cluster,
                    boxpoints: showOutliers ? 'outliers' : false,
                    marker: {color: getClusterColor(d.cluster)}
                };
            });

            const layout = {
                title: `P${percentile} Latency Distribution by Cluster<br><sub>P${percentile} latency across repetitions</sub>`,
                yaxis: {title: `P${percentile} Latency (ms)`},
                margin: {b: 120},
                showlegend: false
            };

            Plotly.newPlot('latencyComparison', traces, layout);
        }

        function updateVariabilityChart(data) {
            const variabilityData = data.map(d => {
                const throughputStats = calculateStats(d.throughput);
                const latencyStats = calculateStats(d.latency);
                return {
                    cluster: d.cluster,
                    clients: d.clients,
                    throughputCV: throughputStats.cv,
                    latencyCV: latencyStats.cv
                };
            });

            const trace = {
                x: variabilityData.map(d => d.cluster),
                y: variabilityData.map(d => d.throughputCV),
                type: 'bar',
                name: 'Throughput CV%',
                marker: {color: variabilityData.map(d => getClusterColor(d.cluster))}
            };

            const layout = {
                title: 'Performance Consistency (Lower CV% = More Consistent)<br><sub>Coefficient of variation across repetitions</sub>',
                yaxis: {title: 'Coefficient of Variation (%)'},
                margin: {b: 120},
                showlegend: false
            };

            Plotly.newPlot('variabilityComparison', [trace], layout);
        }

        function updateEfficiencyChart(data) {
            const efficiencyData = data.map(d => {
                const validThroughput = d.throughput.filter(x => x > 0);
                const validLatency = d.latency.filter(x => x > 0);
                const efficiencies = validThroughput.map((t, i) => calculateEfficiency(t, validLatency[i]));
                const avgEfficiency = efficiencies.reduce((a, b) => a + b, 0) / efficiencies.length;
                
                return {
                    cluster: d.cluster,
                    clients: d.clients,
                    efficiency: avgEfficiency
                };
            });

            const trace = {
                x: efficiencyData.map(d => d.cluster),
                y: efficiencyData.map(d => d.efficiency),
                type: 'bar',
                name: 'Efficiency Score',
                marker: {color: efficiencyData.map(d => getClusterColor(d.cluster))}
            };

            const layout = {
                title: 'Performance Efficiency (Throughput/Latency Ratio)<br><sub>Mean efficiency across repetitions</sub>',
                yaxis: {title: 'Efficiency Score'},
                margin: {b: 120},
                showlegend: false
            };

            Plotly.newPlot('efficiencyComparison', [trace], layout);
        }

        function updateComparisonTable(data) {
            const tbody = document.getElementById('comparisonTableBody');
            tbody.innerHTML = '';

            const percentile = document.getElementById('latencyPercentile').value;
            const latencyField = percentile === '99' ? 'latency' : 
                                percentile === '90' ? 'latency_p90' : 'latency_p50';

            // Calculate rankings
            const rankedData = data.map(d => {
                const throughputStats = calculateStats(d.throughput);
                const latencyData = d[latencyField] || d.latency;
                const latencyStats = calculateStats(Array.isArray(latencyData) ? latencyData : [latencyData]);
                const validThroughput = d.throughput.filter(x => x > 0);
                const validLatency = Array.isArray(latencyData) ? latencyData.filter(x => x > 0) : [latencyData];
                const avgEfficiency = validThroughput.length > 0 ? 
                    validThroughput.reduce((sum, t, i) => sum + calculateEfficiency(t, validLatency[i]), 0) / validThroughput.length : 0;
                
                return {
                    ...d,
                    avgThroughput: throughputStats.mean,
                    avgLatency: latencyStats.mean,
                    throughputCV: throughputStats.cv,
                    efficiency: avgEfficiency,
                    selectedLatency: latencyData
                };
            }).sort((a, b) => b.efficiency - a.efficiency);

            rankedData.forEach((row, index) => {
                const tr = document.createElement('tr');
                const rankClass = index === 0 ? 'winner' : index === 1 ? 'second' : index === 2 ? 'third' : '';
                if (rankClass) tr.className = rankClass;
                
                // Get all latency arrays
                const latencyP99 = Array.isArray(row.latency) ? row.latency : [row.latency];
                const latencyP90 = Array.isArray(row.latency_p90) ? row.latency_p90 : [row.latency_p90];
                const latencyP50 = Array.isArray(row.latency_p50) ? row.latency_p50 : [row.latency_p50];
                
                tr.innerHTML = `
                    <td>${row.cluster}</td>
                    <td>${row.config}</td>
                    <td>${row.clients}</td>
                    <td>${row.throughput[0] || '-'}</td>
                    <td>${row.throughput[1] || '-'}</td>
                    <td>${row.throughput[2] || '-'}</td>
                    <td>${row.throughput[3] || '-'}</td>
                    <td>${latencyP99[0] || '-'}</td>
                    <td>${latencyP99[1] || '-'}</td>
                    <td>${latencyP99[2] || '-'}</td>
                    <td>${latencyP99[3] || '-'}</td>
                    <td>${latencyP90[0] || '-'}</td>
                    <td>${latencyP90[1] || '-'}</td>
                    <td>${latencyP90[2] || '-'}</td>
                    <td>${latencyP90[3] || '-'}</td>
                    <td>${latencyP50[0] || '-'}</td>
                    <td>${latencyP50[1] || '-'}</td>
                    <td>${latencyP50[2] || '-'}</td>
                    <td>${latencyP50[3] || '-'}</td>
                    <td><strong>${Math.round(row.efficiency)}</strong></td>
                    <td>${row.throughputCV.toFixed(1)}%</td>
                    <td><strong>${index + 1}</strong></td>
                `;
                tbody.appendChild(tr);
            });
        }

        function updateStatsSummary(data) {
            let bestThroughput = 0, bestLatency = Infinity, bestEfficiency = 0;
            let bestThroughputCluster = '', bestLatencyCluster = '', bestEfficiencyCluster = '';

            data.forEach(d => {
                const validThroughput = d.throughput.filter(x => x > 0);
                const validLatency = d.latency.filter(x => x > 0);
                
                const maxThroughput = Math.max(...validThroughput);
                const minLatency = Math.min(...validLatency);
                const avgEfficiency = validThroughput.length > 0 ? 
                    validThroughput.reduce((sum, t, i) => sum + calculateEfficiency(t, validLatency[i]), 0) / validThroughput.length : 0;

                if (maxThroughput > bestThroughput) {
                    bestThroughput = maxThroughput;
                    bestThroughputCluster = d.cluster;
                }

                if (minLatency < bestLatency) {
                    bestLatency = minLatency;
                    bestLatencyCluster = d.cluster;
                }

                if (avgEfficiency > bestEfficiency) {
                    bestEfficiency = avgEfficiency;
                    bestEfficiencyCluster = d.cluster;
                }
            });

            document.getElementById('bestThroughput').textContent = bestThroughput.toLocaleString();
            document.getElementById('bestThroughputCluster').textContent = bestThroughputCluster;
            document.getElementById('bestLatency').textContent = `${bestLatency}ms`;
            document.getElementById('bestLatencyCluster').textContent = bestLatencyCluster;
            document.getElementById('bestEfficiency').textContent = Math.round(bestEfficiency);
            document.getElementById('bestEfficiencyCluster').textContent = bestEfficiencyCluster;
        }

        function getClusterColor(cluster) {
            const colors = {
                'c4-144 4k': '#8B4513',
                'c4a-64 64k': '#2E8B57',
                'c4a-64 4k': '#FF6347',
                'c4a-72 64k': '#9932CC',
                'c4a-72 4k': '#FF8C00',
                'c4-96 4k': '#4169E1'
            };
            return colors[cluster] || '#666666';
        }

        // Event listeners
        document.getElementById('metricFocus').addEventListener('change', updateCharts);
        document.getElementById('latencyPercentile').addEventListener('change', updateCharts);
        document.getElementById('clientLoad').addEventListener('change', updateCharts);
        document.getElementById('configFilter').addEventListener('change', updateCharts);
        document.getElementById('showOutliers').addEventListener('change', updateCharts);

        // Initialize
        updateCharts();
    </script>
</body>
</html>
